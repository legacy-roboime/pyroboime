## Conventions

Input: Core -> AI
Output: AI -> Core


## Pre-setup phase

Happens only once, no output will be given until the AI states compatibility.

Input state current protocol version

    ROBOIME_AI_PROTOCOL_VERSION 1

Output state compatibility along with max compatible version

    COMPATIBLE 1

Output for future versions, if current is not supported, also state max
compatible version

    NOT_COMPATIBLE 1

If not compatible Output will EOF and the process is expected to terminate.

## Setup phase

Happens only once, right after pre-setup phase.  If geometry params change
in-game the process will be re-opened so new parameters can be loaded.

Input

    FIELD_WIDTH
    FIELD_HEIGHT
    GOAL_WIDTH
    CENTER_CIRCLE_RADIUS
    DEFENSE_RADIUS
    DEFENSE_STRETCH
    FREE_KICK_FROM_DEFENSE_DIST
    PENALTY_SPOT_FROM_FIELD_LINE_DIST
    PENALTY_LINE_FROM_SPOT_DIST

All fields are in meters (float)


## Update phase

There are update cycles, each cylce begins with an Input in which the latest state
information is sent, the core will wait for an Update before going to the next
cycle.  That means that some raw updates may be skipped if the AI doesn't keep
with the pace of the Core, but that's OK though because the command are made to
have a Decentâ„¢ amount of time.

The formats follow:

Input:

    REF_STATE <REF_TIME_LEFT|-1>
    TIMESTAMP
    BALL_X BALL_Y BALL_VX BALL_VY
    GOALKEEPER_ID
    NUM_ROBOTS
    [ROBOT_ID ROBOT_X ROBOT_Y ROBOT_W ROBOT_VX ROBOT_VY ROBOT_VW] x NUM_ROBOTS
    OPPONENT_NUM_ROBOTS
    [ROBOT_ID ROBOT_X ROBOT_Y ROBOT_W ROBOT_VX ROBOT_VY ROBOT_VW] x OPPNENT_NUM_ROBOTS

- TIMESTAMP: seconds (float)
- NUM_ROBOTS: number of robots (int)
- *_X and *_Y are positions in meters (float)
- *_VX and *_VY are velocities in meters/s (float)
- *_W in radians (float)
- *_VW in radians/s (float)
- REF_STATE: single char any of these:
  - 'S': STOP
  - 'N': NORMAL
  - 'p': PRE_KICKOFF
  - 'k': KICKOFF
  - 'i': INDIRECT
  - 'd': DIRECT
  - 'x': PRE_PENALTY
  - 'y': PENALTY
  - 'P': OPPONENT_PRE_KICKOFF
  - 'K': OPPONENT_KICKOFF
  - 'I': OPPONENT_INDIRECT
  - 'D': OPPONENT_DIRECT
  - 'X': OPPONENT_PRE_PENALTY
  - 'Y': OPPONENT_PENALTY
- REF_TIME_LEFT: for referee states 'kidyKIDY' this is the
  number of seconds (float) left until a fault occurs for not
  putting the ball in normal play, this will be capped to 0 if it happens to be
  less than that.  For other states it's -1 as it doesn't apply.

It's important to note that the referee is already interpreted, meaning if the
state is at NORMAL it is safe to play, no checking for opponent kick has to be
done.

On future versions the protocol may include the Z axis of the ball. Also they
may include the score, it's been left out for now.

Output:

    [ROBOT_ID <COMMAND>] * NUM_ROBOTS

<COMMAND> may be one of the following:

    'D' X Y R <'G'|N> (defend own goal (G) or team robot N at X,Y)
    'A' X Y R <'G'|N> (attack opponent goal (G) or team robot N at X,Y)
    'I' X Y 'B' (intercept ball near X,Y)
    'P' N (pass to team robot N)
    'K' (kick ball to goal)


vim: tw=80
